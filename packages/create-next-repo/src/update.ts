// File System, hard to test for now.
/* istanbul ignore file */
import path from "path";
import fs from "fs-extra";
import chalk from "chalk";
import semver from "semver";
import prettier from "prettier";
import * as changeCase from "change-case";
import {
  getPackageJson,
  replaceFileContent,
  devDependenciesCopyMap
} from "./utils";
import { scriptYarnInstall, scriptYarnAddDependencies } from "./scripts";

const caretRangesRegExp = /^\^\d+\.\d+\.\d+$/;

export async function update(
  repoName: string,
  targetDir: string,
  flags: { install?: boolean }
): Promise<void> {
  if (!fs.existsSync(targetDir)) {
    throw new Error(`Target directory not exists: ${targetDir}`);
  }

  const cwd = process.cwd();
  const packageJson = getPackageJson();
  const targetPackageJsonPath = path.join(targetDir, "package.json");
  let targetPackageJson = JSON.parse(
    fs.readFileSync(targetPackageJsonPath, "utf8")
  );
  const targetCurrentGeneratorVersion =
    targetPackageJson.easyops?.["create-next-repo"] ?? "0.4.10";
  const newFilesFromTemplates: string[] = [];
  const overwriteFilesFromTemplates: string[] = [];
  const filesToRemove: string[] = [];
  const templateDir = path.join(__dirname, "../template");

  if (semver.lt(targetCurrentGeneratorVersion, "0.9.0")) {
    await scriptYarnAddDependencies(targetDir);
  }

  targetPackageJson = JSON.parse(
    fs.readFileSync(targetPackageJsonPath, "utf8")
  );

  const translations: Record<string, string> = {
    "$kebab-repo-name$": repoName,
    "$Title Repo Name$": changeCase.capitalCase(repoName),
    "$generator.version$": `v${packageJson.version}`
  };

  if (semver.gte(targetCurrentGeneratorVersion, packageJson.version)) {
    console.log(
      `Current create-next-repo version in target: ${targetCurrentGeneratorVersion} is >= cli version: ${packageJson.version}`
    );
    return;
  }

  console.log(chalk.inverse("[create-next-repo]"));

  if (semver.lt(targetCurrentGeneratorVersion, "0.6.0")) {
    const readmePath = path.join(targetDir, "README.md");
    if (fs.existsSync(readmePath)) {
      if (
        fs
          .readFileSync(readmePath, "utf8")
          .includes("Generated by [@easyops/create-next-repo]")
      ) {
        overwriteFilesFromTemplates.push("README.md");
      }
    }
  }

  if (semver.lt(targetCurrentGeneratorVersion, "0.6.2")) {
    overwriteFilesFromTemplates.push(".gitignore");
  }

  if (semver.lt(targetCurrentGeneratorVersion, "0.8.0")) {
    fixHomepage();
  }

  if (semver.lt(targetCurrentGeneratorVersion, "0.9.0")) {
    removeFeatureSyncDll();
    fixDevDependencies();
  }

  syncPackageJson();
  syncFiles(newFilesFromTemplates, "new");
  syncFiles(overwriteFilesFromTemplates, "overwrite");
  removeFiles(filesToRemove);

  if (flags.install) {
    await scriptYarnInstall(targetDir);
    // Run `yarn` again since dll maybe updated.
    await scriptYarnInstall(targetDir);
  }

  function removeFeatureSyncDll(): void {
    delete targetPackageJson.scripts["sync-dll"];
    filesToRemove.push("scripts/sync-dll.js");
  }

  function syncPackageJson() {
    // 1. Update `easyops.create-next-repo` in `package.json`
    if (!targetPackageJson.easyops) {
      targetPackageJson.easyops = {};
    }
    targetPackageJson.easyops["create-next-repo"] = packageJson.version;

    // 1. Update `devDependencies` in `package.json`
    for (const dep of devDependenciesCopyMap.templateDependencies) {
      const fromVersion = targetPackageJson.devDependencies[dep];
      const toVersion = packageJson.templateDependencies[dep];
      if (fromVersion) {
        if (
          caretRangesRegExp.test(fromVersion) &&
          caretRangesRegExp.test(toVersion)
        ) {
          if (semver.gte(fromVersion.substr(1), toVersion.substr(1))) {
            // Ignore newer dependencies.
            continue;
          }
        }
      }
      targetPackageJson.devDependencies[dep] = toVersion;
    }

    fs.outputFileSync(
      targetPackageJsonPath,
      prettier.format(JSON.stringify(targetPackageJson), {
        parser: "json"
      })
    );
    console.log(
      `${chalk.bold("File updated")}: ./${path.relative(
        cwd,
        targetPackageJsonPath
      )}`
    );
  }

  function syncFiles(files: string[], type: "new" | "overwrite"): void {
    const newFiles = files.map(filePath => [
      path.join(targetDir, filePath),
      replaceFileContent(path.join(templateDir, filePath), translations)
    ]);
    for (const [filePath, content] of newFiles) {
      fs.outputFileSync(filePath, content);
      console.log(
        `${chalk.bold(
          type === "new" ? "File created" : "File updated"
        )}: ./${path.relative(cwd, filePath)}`
      );
    }
  }

  function removeFiles(files: string[]): void {
    for (const filePath of files) {
      const absFilePath = path.join(targetDir, filePath);
      if (fs.existsSync(absFilePath)) {
        fs.unlinkSync(absFilePath);
      }
    }
  }

  function fixHomepage(): void {
    if (
      !targetPackageJson.homepage ||
      !targetPackageJson.homepage.endsWith(repoName)
    ) {
      // Fix root homepage.
      targetPackageJson.homepage = `https://git.easyops.local/anyclouds/${repoName}`;
    }

    ["bricks", "libs", "micro-apps", "templates"].forEach(type => {
      const typeDir = path.join(targetDir, type);
      if (!fs.existsSync(typeDir)) {
        return;
      }
      fs.readdirSync(typeDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .forEach(dirent => {
          const pkgJsonPath = path.join(typeDir, dirent.name, "package.json");
          if (fs.existsSync(pkgJsonPath)) {
            const pkgJson = JSON.parse(fs.readFileSync(pkgJsonPath, "utf8"));
            let modified = false;
            if (!pkgJson.homepage || pkgJson.homepage.startsWith("undefined")) {
              // Fix `undefined`-prefixed homepage.
              pkgJson.homepage = `${targetPackageJson.homepage}/${repoName}/tree/master/${type}/${dirent.name}`;
              modified = true;
            }
            if (!pkgJson?.repository?.url?.endsWith(`${repoName}.git`)) {
              // Clear wrong `repository`.
              delete pkgJson.repository;
              modified = true;
            }
            if (modified) {
              fs.outputFileSync(
                pkgJsonPath,
                prettier.format(JSON.stringify(pkgJson), {
                  parser: "json"
                })
              );
              console.log(
                `${chalk.bold("File updated")}: ./${path.relative(
                  cwd,
                  pkgJsonPath
                )}`
              );
            }
          }
        });
    });
  }

  // Remove all packages those are included in `@easyops/dev-dependencies`
  // from target's `devDependencies`.
  function fixDevDependencies(): void {
    const json = require(require.resolve(
      "@easyops/dev-dependencies/package.json",
      {
        paths: [targetDir]
      }
    ));
    for (const pkgName of Object.keys(json.dependencies)) {
      // Todo(steve): size-limit not working.
      if (!pkgName.startsWith("@size-limit/")) {
        delete targetPackageJson.devDependencies[pkgName];
      }
    }
  }
}
